1月18日
1.函数式 
2.回调 系统事件
3.订阅-发布模式
4.序列化json
5.统一容器 map list ，Obj等价 obj[1] == obj.1，obj[key] == obj.key
6.多线程，每个方法调用默认都创建一个线程 参数以copy方式传递，线程返回触发回调，也可以有传统的并行多线程，前提分配好各线程的

资源，线程有层次优先级，可以“催促”，“催促”可以按调用栈传递
7.虚拟线程方式
9.虚拟机，虚拟内存
10.对象之间支持比较，排序，可以自定义排序标准
11.持有=继承
12.数据和方法分离，但是按照统一的方式处理，（数据和函数的区别在于数据是变动的，函数是不变的，但是可以以自身方式发展，比如递

归）
13.远程方法调用
14.读的时候一律是取共享数据，只有写的时候才copy，降低copy成本
15.对象的属性（数据和方法）支持排序，可以动态控制执行顺序，任意插入方法。
16.所有对象生成的时候，一律加时间，地点。
17.在方法调用的时候，申明自己需要的资源，但给的资源多于所需，不报错，资源不够才报错
18.队列的支持，锁的支持，因为还是要涉及多线程更新共享资源的问题。队列也可解决通信先后顺序问题
19.二进制数据的支持，参照erlang，通信协议的支持
20.和各种语言的通信，调用
21.对象之间可以像流体一样转化
22.对于内存，磁盘，网络的操作统一
23.程序员可以确定已确定的东西，最后产出肯定包含我所需要的东西，但是可以有多出来的东西，这些是有用的，程序员当初没想到
24.接口蕴含在定义的对象中，不需额外定义
25.始终将已确定的框架和需要的数据分离，时间空间都要分离，目前的web渲染方式是极其错误的，界面是固定的可以先展示，数据变动的可

以后展示。所有的程序调用都可看做web取数据，展示，把变动的数据看成未知，固定的东西不依赖于这些未知因素。



1月29日
1.语言级的回调
2.任意方法执行创建多线程，执行完毕回调
3.动态执行的代码和编译器编译的一模一样，运行期的编译器，代码在内存中的组织，管理
4.线程间传递数据都是拷贝（分清楚拷贝 和 共享资源|引用）
5.如果可以优化性能，这样做：读取时都是引用，写的时候，才在自己线程开辟空间，拷贝一份，再写，涉及线程以及他自己的内存空间的管理组织
6.一切数据都是容器，统一容器；数据其实是对象运行所需要的资源。
7.方法执行时才实例化对象，其实是实例化线程，轻量级线程虚拟机
8.类就是对输入数据的格式进行规范，接口就是对输入和输出都进行规范的类，任何类都隐含是接口（接口和类的统一）
9.继承就是在类创建的时候把父母类的所有东西都拷贝一份，加工结合，至于以后就跟父母类没有关系了，这就像是基因。（程序员就是造物主，决定怎么结合）
10.运行时对一切方法，变量的查找，支持正则，迫使程序员关注命名问题
11.数据其实是树结构，线程创建也是树结构，对树要有抽象的操作，比如层级查找统计，簇查找统计。list是特殊的map，map是特殊的树
12.有管理的哲学意识，任何东西都要可管理，可监控（）
13.数据像水一样流动（支持转化，过滤，添加），对象像人一样繁殖（第9条）
14.所有基本类型只有字符串，数字，二进制；字符串是特殊的二进制

1月30日
类比的能力，所有动物，都有嘴，可以吃饭，有消化系统，神经系统，呼吸系统，都有，但是各物种之间有细微的差别，以适应各自不同的环境
从时间的角度，是一个祖先，经过几百万年的进化，到各个具体不同的物种
不变的东西，恰恰是在变化中积累下来的，没有变化就分不出什么是变化的，什么是不变的。。
但问题是，什么东西是真正不变的，我们不知道，也不能妄下定论
所以真正永恒的东西，我们还是要把它看成未知数
但是，变化的东西在一个时间段，是有其固定的形式的，他下一个时间段的形式，要靠这个时间段的形式来形成，所以提取不变的东西，是一个迭代的过程

某一经典的形式，必然包含很多的哲学，有很多自描述的，全息性的东西，但表现形式却是十分的简洁，例如，弦乐乐器看似简单，发出的声音却十分复杂；erlang也是这样
从各个方面，各个角度去理解这个形式，都发现很有启发意义，这是经典的东西
